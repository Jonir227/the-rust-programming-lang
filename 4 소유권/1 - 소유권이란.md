# 소유권이란?

컴퓨터는 메모리 관리가 반드시 필요하다. 어떤 언어는 사용하지 않는 메모리를 자동으로 해제해주고, 어떤 언어는 프로그래머가 직접 해재해 주어야 한다.

러스트는 다른 방법을 사용하는데, 메모리는 컴파일러가 컴파일할 시점에 검사하는 "소유권"규칙에 따라서 관리된다.

## 스택과 힙

- 스택과 힙은 코드가 런타임에 활용하는 메모리의 일부이다.
- 스택에 저장되는 정보는 고정된 크기를 가져야함
- 힙은 런타임에 동적으로 크기가 변하는 데이터가 저장된다.
- 코드에서 함수를 호출할 때 이 함수에는 힙 메모리에 저장된 데이터에 대한 포인터를 포함한 여러 값이 전달되며 이 값들은 함수의 로컬 변수에 할당되어 스택에 저장됨. 함수의 실행이 완료되면 이 값들은 스택에서 제거된다.
- 이때, 코드의 어느 부분이 힙 메모리에 저장된 데이터를 사용하는지 추적하고 힙에 저장되는 데이터가 사용되지 않으면 즉시 힙 메모리에서 제거하면 메모리 부족 문제를 해결할 수 있다. 이것이 러스트에서 사용하는 소유권의 개념이다.

## 소유권 규칙

- 러스트가 다루는 값은 소유자라고 부르는 변수를 가지고있음
- 특정 시점의 소유자는 **단하나**
- 소유자가 범위를 벗어나면 그 값은 제거됨.

## 변수의 범위

다음 코드를 보자

```rust
{                  // 변수 선언하지 않았으므로 유효 x
  let s = "hello"; // 선언한 시점이므로 이지점부터 유효
  // do something
} // 더이상 유효하지 않음
```

- 변수가 범위 안으로 들어오면 유효.
- 변수는 범위를 벗어나기 전까지 유효

## String type

앞에서 확인해본 타입은 스택에 저장되는 타입들이지만 `String`타입은 그렇지 않다. `String`뿐만이 아니다. 라이브러리가 제공하거나 개발자가 직접 구현하게 될 타입들도 역시 마찬가지이다.

러스트는 다음과 같은 방식을 통해 소유권을 확인한다.

```rust
let s = String::from("hello"); // 문자열 리터럴과는 다르게 스트링 인스턴스를 생성했다.

// 이렇게 생성한 문자열은 변경이 가능하다.
let mut s = String::from("hello");

s.push_str(", world!");

println!("{}", s); // hello, world!
```

문자열 리터럴로 했다면 변경을 못했을 것이다. 문자열 리터럴과 `String`이 다른 점은 메모리를 다루는 방법에 있다.

## 메모리 할당.

- 문자열 리터럴은 컴파일 시점에 문자열의 내용을 이미 알고있으므로 텍스트를 최종 실행할 수 있는 형태로 직접 하드코딩 가능하다.
- 이 말은 문자열 리터럴이 불변이라는 말이다.
- 따라서 변경가능한 문자열을 위해서는 힙 메모리에 할당해야한다. 따라서 `String`을 사용한다.
- 이때 힙 영역에 할당하는 데이터는 두가지 절차를 거친다.
  - 메모리는 반드시 런타임에 운영체제에 요청되어야 한다.
  - `String`타입의 사용이 완료된 이후에는 메모리를 운영체제에 돌려줄 방법이 필요하다.
- 첫번째 절차는 개발자가 처리가능. 하지만 두번째는 다르다.
- GC를 사용하는 언어는 언어가 알아서 해줌. GC가 없는 언어는 더이상 필요없는 시점을 개발자가 알아서 해주어야함.

러스트는 이런 방법과 조금 다르게 작동한다.

```rust
{
  let s = String::from("hello");
} // 이 시점에 해제된다.
```

rust는 변수가 범위를 벗어나는 시점에 메모리를 해제하는 `drop`이라는 함수를 호출한다.

변수가 유효하지 않은 시점에 해제하는것이다. 이런 패턴을 "초기화에 의한 자원 획득(RAII)"이라고 부른다. 간단해 보이지만 복잡한 상황에서는 코드가 예상과는 다르게 동작할 수 있다.

### 변수와 데이터가 상호작용하는 방식: 이동(MOVE)

이 상황에서는 값의 복사가 이루어진다.

```rust
let x = 5;
let y = x;
```

스택에 x, y라는 값(5)두개가 저장된다. 하지만 `String`은 다르다.

```rust
let s1 = String:from("hello");
let s2 = s1;
```

이때는 s1이 가리키고 있는 주소가 s2로 이동된다. 이때는 주소만 이동된 것이기 때문에 같은 데이터를 가리키고있다. **복사가 아니다!**

다른 언어에도 비슷한 일(얕은복사)이 일어난다. 하지만 rust에서는 이 현상이 조금 다르다. 변수가 범위를 벗어날때 `drop`함수를 호출하게 되는데 두 변수가 모두 사용가능한 상태라면 똑같은 데이터를 해제하려고 하기 때문에 에러가 발생할 수 있다. 따라서 러스트는 이런 현상이 일어났을때 첫번째 변수 `s1`이 더이상 유효한 변수라고 판단하지 않는다.

이 동작은 복사와는 다르므로 **이동** 이라고 부른다.

### 변수와 데이터가 상호작용하는 방식: 복제(Clone)

그러면 깊은 복사는 어떻게 해야할까? `clone`이라는 공용 메서드를 사용하면 된다.

```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```

### 스택 전용 데이터:복사(clone)

앞선 예제와 같이 스택 전용 데이터들은 복사된다. 그 데이터 타입들은 다음과 같다.

- u32와 같은 정수형 타입
- 불리언 타입
- 문자 타입
- f64와 같은 부동소수점 타입
- copy 트레이트가 적용된 타입을 포함하는 튜플
  - 예) (i32, i32)

## 소유권과 함수

값을 함수에 전달한다는 의미는 값을 변수에 대입하는것과 유사함. 변수를 함수에 전달하면 대입과 마찬가지로 값의 이동이나 복사가 이루어짐.

```rust
fn main() {
  let s = String::from("abc");

  takes_ownership(s); // 이 시점에서 s는 유효하지 않음

  let x  = 5;

  makes_copy(x);
} // x는 여기서 해제된다

fn takes_ownership(some_string: String) { // some_string의 소유권을 넘겨받는다.
  println!("{}", some_string);
} // some_string.drop();

fn makes_copy(some_integer: i32) { // "복사"가 일어난다.
  println!("{}", some_integer);
} // 아무일도 일어나지 않음
```

## 리턴값과 범위

리턴값도 소유권을 이전한다.

```rust
fn main() {
  let s1 = gives_ownership(); // 함수로부터 생성된 string 소유권이 s1로

  let s2 = String::from("hello");

  let s3 = takes_and_gives_back(s2); // s2 -> 함수 -> s3로 소유권이 이동한다.
}

fn gives_ownership() -> String {
  let some_string = String::from("hello");

  some_string
}

fn takes_and_gives_back(a_string: String) -> String {
  a_string
}
```
