# Variables and Mutability

기본적으로 러스트에서 모든 변수는 immutable 하다. 이는 안전하고, 쉬운 병렬 프로그래밍을 가능하게 해주는 러스트의 제공 환경 중 하나이다. 항상 immutable 한 것은 아니고 러스트는 mutable 하게 다루게 해주는 옵션을 제공한다.

```rust
fn main() {
  let x = 5;
  println!("the value of x is {}", x);
  x = 6;
  println!("the value of x is {}", x);
}
```

상단의 코드는 에러가 난다. 이뮤터블한 변수 x 의 값이 변경되었기 때문! 따라서 러스트를 컴파일하는 과정에서 컴파일 에러가 난다.

이를 해결하기 위해서는 다음과 같이 작성해야한다.

```rust
fn main() {
  let mut x = 5;
  println!("the value of x is {}", x);
  x = 6;
  println!("the value of x is {}", x);
}
```

`mut`키워드로 변수를 변경가능하게 만들 수 있다.

버그를 막기 위해서는 트레이드 오프가 존재한다. 예를 들어서, 엄청나게 거대한 데이터 구조를 다룰 때에 값을 변경하는 것이 새로운 데이터를 생성하는 것보다 빠를 수가 있다. 하지만 작은 자료 구조 에서는 새로운 인스턴스를 생성하여 내려주는 것이 좀 더 함수형에 가까우며 읽기 편하다. 따라서 비교적 느린 퍼포먼스로 명확성을 받는 대가로는 가치있는 패널티라고 볼 수 있다.

## 변수와 상수와의 차이

값을 변경할 수 없는 컨셉은 대부분의 다른 언어들 또한 가지고 있는 `const`를 떠올리게 한다. immutable 한 변수처럼 `const`는 이름이 고정되어 있고 값을 변경할 수 없다. 하지만 변수와 `cosnt`사이에는 차이가 존재한다.

1. `const`는 `mut`를 사용할 수 없다. `const`는 기본적으로 이뮤터블 한것이 아니고 항상 이뮤터블하다.
2. `const`로 변수를 선언했다면 `let`과는 다르게 반드시 값의 타입이 명시되어야한다.
3. 상수는 어떤 스코프에도 선언이 가능하다. 전역 스코프에도 선언가능
4. 상수는 constant expression 으로만 선언이 가능하다. 함수의 결과나 다른 computed value 로 값이 할당될 수 없다.

다음은 상수 선언의 예시이다.

```rust
// 러스트의 상수 네이밍 컨벤션은 전부대문자이며 _ 로 연결된 것이다.
const MAX_POINTS: u32 = 100_000;
```

상수는 속한 스코프 내라면 프로그램 전체에서 살아있으며, 다양한 부분에서 알아야 할 값들 - 예를 들어 게임에서의 최대 점수 값 같은것들 - 에 대하여 정보를 준다.

## 쉐도잉

챕터 2 의 예시에서 보았듯이 이전에 선언한 변수와 같은 이름의 변수를 다시 선언할 수 있다. 이렇게 되면, 새 변수는 이전에 선언했던 변수룰 "가린다". 이를 쉐도우 되었다고 표현한다.

다음은 쉐도잉의 예시이다.

```rust
fn main() {
  let x = 5;
  let x = x + 1;
  let x = x * 2;
  println!("the value of x is {}", x); // 12
}
```

쉐도잉은 `mut`로 변수를 뮤터블하게 바꾸는 것과는 다르다. 만약 직접 값을 바꾸려고 시도하면 컴파일 시점에서 에러를 뱉기 때문이다. `let`키워드로 다시 선언함으로서 값을 다시 immutable 하게 새로 할당할 수 있는 것이다.

`mut`과 `let`의 또다른 차이점은 `let`을 사용해서 한번 더 변수를 선언하면 쉽게 타입을 변경할 수 있다는 점이다. 다음은 그 예시이다.

```rust
let spaces = "   ";
let spaces = spaces.len();
```

처음에 할당된 string 타입이 `let`을 이용해서 다시 변수를 생성해 줌 으로서 `number`타입으로 바꿀 수 있었다. 당연히 이하의 코드는 컴파일 시점에서 에러가 난다.

```rust
let spaces = "   ";
spaces = spaces.len();
```
